# `string`与`char*

```cpp
// 速查注释：在本项目中 std::string 与 char* 的使用边界
// 1) 读写属性：
//    - std::string        -> 拥有与管理内存（自动增长/释放），适合“我持有这段文本”
//    - const char* / char*-> 只是一段原始指针，不拥有内存（生命周期由外部控制）
// 2) API 选择：
//    - 只读入参：优先 string_view（或 const std::string&），必要时接受 const char*
//    - 产生文本返回：std::string
//    - 需要把数据写进调用者缓冲：用 (char*, size_t) 或 std::span<char>（而不是 std::string）
//    - 与 printf/va_list 交互：格式串用 const char*，填充目标用 char* + 长度
// 3) 项目内典型用法：
//    - Logger::info(fmt, ...): 入参走 const char* + 可变参（printf 风格）
//    - vformat(): 先用 vsnprintf(nullptr,0,...) 求长度，再写入 char* 缓冲，最后生成 std::string
//    - Formatter/Sink：在模块间传递 std::string（已构造好的整行日志文本）
// 4) 常见坑：
//    - c_str()/data() 指针失效：一旦 string 被修改/resize，旧指针作废
//    - C API 要求可写缓冲：不要把 string 的 data() 当作“可写”在 C++17 之前；写入请先 resize(n+1)
//    - 嵌入 '\0'：C 风格 %s 以 '\0' 终止，遇到中间 0 会被截断；用长度版 API 传二进制数据
```

## 一、基础对比与“语义—实现”区分


| 维度         | `std::string`                  | `const char*`/`char*`                      |
| ------------ | ------------------------------ | ------------------------------------------ |
| 所有权       | 拥有并管理堆内存               | 不拥有；仅指向外部内存                     |
| 生命周期     | RAII 自动释放                  | 由提供者决定；易悬空                       |
| 长度信息     | 内部保存 size                  | 通过约定（以`'\0'`终止）或额外参数传入     |
| 可变性       | 内容可变（改动可能触发重分配） | `const char*`只读；`char*`可写但需保证容量 |
| 接口友好     | C++ 风格、异常安全             | 与 C 库/系统 API 互操作友好                |
| 二进制安全   | 支持嵌入`'\0'`（长度独立）     | 以`'\0'`终止的函数不二进制安全             |
| 线程安全     | 对象内操作需外部同步           | 同上；指针更易被误用                       |
| 常见实现细节 | 小字符串优化（SSO）、按需增长  | 无                                         |

要点：

* `std::string` 是“值语义”的文本容器；
* `char*` 是“裸内存视图”，需要你自己承担容量、生命周期与终止符责任。

## 二、项目内数据流与各自职责

以一次日志调用为例（你当前最小可运行版）：

1. `Logger::info(const char* fmt, ...)`
   * 选择 `const char*` 作为格式串，是为了与 C 的 `printf/va_list` 生态无缝互通。
2. `vformat(fmt, va_list)`
   * 第一次 `vsnprintf(nullptr,0,...)` 只计算“需要的字节数 n”；
   * 准备**可写缓冲区**（`std::string` 先 `resize(n+1)` 或 `std::vector<char>(n+1)`），再调用 `vsnprintf(buf, n+1, ...)` 写入，最后把数据变为 `std::string`。
   * 这一步是“**char* 世界*\*”与“**std::string 世界**”的桥。
3. 生成 `std::string payload`
   * 从现在开始，建议都用 `std::string` 在模块间传递，避免悬空。
4. `Formatter::format(const LogMsg&) -> std::string`
   * 产出**整行**日志文本（`std::string`）。
5. `Sink::log(const std::string&)`
   * 只读消费，不改内容。

设计思想：

* \*\*外部边界（与 C/系统库交互）\*\*用 `char*` / `const char*` + 长度；
* **内部模块**尽量使用 `std::string` / `std::string_view` 传递不可变文本，简化生命周期管理。

## 三、典型场景与“正确写法”

### 场景 A：把 C 风格文本传入你的库（只读）

```cpp
void log_message(const char* msg) {               // 仅只读
  std::string s(msg);                              // 若需长期持有，拷贝一份
  // 或不拷贝：函数内临时使用，直接传 string_view(msg)
}
```

推荐：库的**只读入参**可以声明为 `std::string_view sv`，调用者可传 `const char*` 或 `std::string`，零拷贝且统一。

### 场景 B：让 C 库把内容写进你的缓冲（可写）

```cpp
// 错误：把 string 的 data() 当可写缓冲（C++17 之前是 const char*）
std::string s(n, '\0');     // size==n
c_api_write(s.data(), n);   // 若写入终止符 s[n] -> 越界/未定义

// 正确：先扩到 n+1，再回缩
std::string s; s.resize(n + 1);
c_api_write(s.data(), s.size());
s.resize(n);
```

更通用：`std::vector<char> buf(n + 1); c_api_write(buf.data(), buf.size());` 再构造 `std::string(buf.data(), n)`。

### 场景 C：printf/va\_list 格式化（你项目中的 vformat）

```cpp
va_list ap2; va_copy(ap2, ap);
int n = vsnprintf(nullptr, 0, fmt, ap2);  // 计算长度（不含 '\0'）
va_end(ap2);
std::string s; s.resize(n + 1);
vsnprintf(s.data(), s.size(), fmt, ap);   // 写入包括终止符
s.resize(n);                              // 去掉 '\0'
return s;
```

### 场景 D：避免悬空的三条“铁律”

1. 不要保存 `std::string::c_str()` / `data()` 返回的指针到外部长期使用；
2. 只要对 `string` 做了 `append/resize/assign` 等可能重分配的操作，**之前拿到的指针一律视为失效**；
3. 若必须跨作用域保存指针，请改为保存 `std::string` 本身（或 `shared_ptr<std::string>`）。

## 四、什么时候用 `std::string_view`

`string_view` 是“**只读、不拥有**”的字符串视图，适合当**入参类型**：

* 优点：零拷贝；可接 `const char*`、`std::string`、字面量；与 `std::span<const char>` 类似；
* 注意：只是“看一眼”，不能延长数据寿命。函数内部**绝不**把传入的 `string_view.data()` 跨作用域保存；若要保存，立刻拷贝成 `std::string`。

在你的项目中，可考虑把 Formatter 的某些静态小助手写成：

```cpp
void write_kv(std::string& out, std::string_view k, std::string_view v);
```

这样可以避免反复构造临时 `std::string`。

## 五、与编码、二进制安全相关的注意点

* `%s`、`std::cout << c_str()` 都把 `'\0'` 当结束：若 payload 中有二进制 0，会被截断。日志一般是文本，不建议塞入任意二进制；如确需，必须使用带长度的接口。
* 跨平台编码（UTF-8/GBK/本地码页）问题与 `std::string` 类型无关，它只是字节序列容器；统一用 UTF-8 最稳妥。
* 文件/终端写入时若遭遇乱码，多半是“终端/文件查看器的解码设置”问题，而不是 `std::string` 的问题。

## 六、项目内 API 设计建议（可渐进演进）

1. 用户接口层（对外）：
   * 继续保留 `info(const char* fmt, ...)` 这套 printf 风格，以便迁移旧代码；
   * 另外提供一套现代接口：`info(std::string_view msg)` 或 `info(fmt::format_string<...> F, Args&&... args)`（若引入 {fmt}）。
2. 模块间传递：
   * `Formatter::format` 与 `Sink::log` 保持 `const std::string&`（或 `std::string_view`）即可；
   * 需要拼接时在一个本地 `std::string` 上 `append`，最终一次性下发给 Sink，减少短命临时对象。
3. 写入缓冲：
   * 与 C API/`vsnprintf` 交互时，不要把 `std::string` 当“长度就是容量”的缓冲使用；明确用 `resize(n+1)` 或用 `std::vector<char>`。

## 七、常见误区与反例

* 误区：`std::string::c_str()` 得到的是“永远有效的全局指针”。
  纠正：只在该 `string` 当前内容与容量不被修改的生命周期内有效，一旦修改即可能失效。
* 误区：`std::string::data()` 总是 `char*`。
  纠正：C++17 起是 `char*`，C++11/14 返回 `const char*`。用旧标准的 IntelliSense 会有不兼容提示。
* 误区：把 `std::string_view` 存下来以后再用。
  纠正：它不拥有数据，指向的底层数据可能已经被释放或移动，必须在使用前确认仍然有效，跨作用域存放要改拷贝。

## 八、结合你的代码给出两处可改良点

1. `vformat` 改成“先 `resize(n+1)`，写完再 `resize(n)`”，避免越界与未定义行为（你已经注意到这点）。
2. `Sink::log(const std::string&)` 保留；如果将来要支持网络或二进制日志，新增一个重载 `log(const char* data, size_t len)`，避免 `'\0'` 截断问题。

# 单元测试

# 1) 先给一个“判断题”：我面对的模块是什么类型？

拿到一个函数/类，先给它贴标签（越左越简单、越右越难）：

* **纯函数**（输入→输出，无副作用）：例如 `parse_pattern(s) -> tokens`、`format_time_point(tp) -> string`
* **同步副作用**（文件/网络/环境变量/系统调用）：`FileSink::log(...)`
* **异步/并发**（线程、队列、定时器、回调）：`AsyncLooper::push/stop`
* **状态机/长生命周期对象**（Builder/Manager/连接池）
* **性能敏感路径**（格式化、拷贝、内存管理）

贴完标签，你就知道用哪套测试套路（下面第 3 节有“模块→套路”的对照表）。

---

# 2) 每个测试都遵守的“AAA 三段式 + 命名规范”

* **Arrange（准备）**：构造输入与依赖（必要时**注入假对象 fake/mock**）
* **Act（执行）**：调用被测 API
* **Assert（断言）**：校验返回值/状态/副作用
* **命名**：`模块_场景_期望()`，例如 `Formatter_TimeMillis_ZeroPadded()`
* **原则**：**可重复、快速、确定性**（不受时区、网络、随机数、线程调度影响）

---

# 3) 模块类型 → 对应测试套路（拿你日志项目举例）

## A. 纯函数/近似纯函数（最容易）

**例子**：`format_time_point`、未来的 `parsePattern`
**套路**：

* 列举输入 → 精确输出；边界（空、极大、非法）
* **属性测试**（property-based）：比如“format 再 parse 不丢信息”
* **快速对拍**：用与你实现**同规**的参考实现生成期望串（我在 formatter 测试里就是这么干的）
  **反模式**：依赖系统环境（时区/locale）。要么注入、要么在测试里用相同算法构造期望值。

## B. 同步副作用（文件/终端/系统）

**例子**：`FileSink::log`、`RollSink`
**套路**：

* **沙箱目录**：每个测试创建唯一临时目录（`/tmp/bitlog-test-XXXX`），用完删除
* **黄金文件（golden file）**：写入后对比文件内容（或只校验结构：行数/前缀）
* **错误注入**：只读目录、磁盘满（难模拟，可用“拒写 fake 文件对象”代替）
  **反模式**：依赖真实工作目录；不清理临时文件；测试间互相污染。

## C. 异步/并发（难点）

**例子**：`AsyncLooper`、`AsyncLogger`
**套路**：

* **依赖注入**：时间、后端 Sink、队列容量都可注入；这样你能控制行为
* **屏障/闩锁**（barrier/latch）同步步骤，消除调度不确定性
* **等待有超时**：`cv.wait_for(… 100ms)`，断言成功；失败时打印诊断信息
* **顺序与完整性**：用**可记录的假 Sink**（`FakeSink`：收集写入字符串）来断言“条数/顺序/无丢失”
* **停机语义**：`stop()` 期间无死锁；`push()` 在停止后要么马上失败、要么安全返回
  **反模式**：sleep 盲等；无超时等待；依赖幸运的线程调度；“偶尔红”的**脆弱测试**。

## D. 状态机/Builder/Manager

**例子**：`GlobalLoggerBuilder`、`loggerManager`
**套路**：

* **可观察状态**：为测试提供“只读接口”（如 `hasLogger(name)`）或返回构造结果
* **排列组合**：无 formatter/无 sink/多 sink/重复注册/重名覆盖
* **不变量**：注册表里不重复、默认 root 存在、析构后不能再取
  **反模式**：只能靠日志或 private 成员去“猜”；暴露太多实现细节。

## E. 性能敏感路径（基准测试，而不是单元测试）

**例子**：格式化/序列化
**套路**：

* 微基准（micro-benchmark）：固定输入 100 万次，统计时间（Release、关闭日志）
* **对照组**：iostream vs snprintf vs {fmt}，长度 50/100/500B
* **不做**：在单元测试里断言“耗时 < X ms”（波动大、不稳定）

---

# 4) 让代码“易测”的 7 条设计建议（写代码时就埋好测试缝）

1. **依赖注入**（DI）：把“时间、输出、队列、随机数”等外部依赖通过构造函数/参数传入

   ```cpp
   struct Clock { virtual ~Clock()=default; virtual tp now() const=0; };
   struct SystemClock : Clock { tp now() const override { return system_clock::now(); } };
   class AsyncLooper {
     explicit AsyncLooper(std::shared_ptr<Clock> c, size_t cap, Sink::ptr s);
   };
   ```

   测试时传 `FakeClock`，就能制造“时间不动”“快进 1s”等情景。
2. **分离纯/副作用**：先在纯函数里构造字符串，再由 I/O 层一次写出；纯函数好测、I/O 层做冒烟。
3. **为测试提供“观察口”**：例如 `size()`、`pending()`、`droppedCount()` 的只读方法，或把事件回调给测试。
4. **控制并发入口**：对外提供 `start()/stop()`；`stop()` 保证幂等；内部条件变量等待都带 `_running==false` 的短路。
5. **错误可见**：返回 `bool`/`status` 而不是静默吞掉；测试可以断言错误码。
6. **避免全局可变状态**：root logger 可以单例，但其依赖最好可注入（可选）。
7. **可替换实现**：接口 + 实现分离，测试里用假的实现替代（`FakeSink`、`FakeQueue`）。

---

# 5) CMake/CTest 固化模板（复制到你的工程即可用）

在 `CMakeLists.txt` 末尾：

```cmake
include(CTest)

function(add_ut NAME)
  add_executable(${NAME} ${ARGN})
  target_link_libraries(${NAME} PRIVATE bitlog)
  # 测试用：开启更多告警/禁优化便于调试
  target_compile_options(${NAME} PRIVATE -O0 -g -Wall -Wextra -Wpedantic)
  add_test(NAME ${NAME} COMMAND ${NAME})
endfunction()

if(BUILD_TESTING)
  add_ut(formatter_tests tests/formatter_tests.cpp)
  # 将来：
  # add_ut(file_sink_tests tests/file_sink_tests.cpp)
  # add_ut(async_looper_tests tests/async_looper_tests.cpp)
endif()
```

> 运行：
> `cmake -S . -B build -DBUILD_TESTING=ON && cmake --build build -j && ctest --test-dir build -V`

---

# 6) 三类“通用假对象”代码片段（直接拿去用）

## (1) 捕获写入的 FakeSink（测 Logger/Looper 输出）

```cpp
struct FakeSink : bitlog::LogSink {
  std::mutex m; std::vector<std::string> lines;
  void log(const std::string& s) override {
    std::lock_guard<std::mutex> lk(m);
    lines.push_back(s);
  }
  size_t count() const { return lines.size(); }
};
```

## (2) 可控时间的 FakeClock（测时间相关逻辑）

```cpp
using tp = std::chrono::system_clock::time_point;
struct FakeClock : Clock {
  tp now_{tp{}};
  tp now() const override { return now_; }
  void set(tp t) { now_ = t; }
  void advance(std::chrono::milliseconds d) { now_ += d; }
};
```

## (3) 屏障/闩锁（并发测试同步起跑）

```cpp
struct Latch {
  std::mutex m; std::condition_variable cv; int cnt;
  explicit Latch(int n):cnt(n) {}
  void arrive_and_wait() {
    std::unique_lock<std::mutex> lk(m);
    if (--cnt == 0) cv.notify_all();
    else cv.wait(lk, [&]{ return cnt==0; });
  }
};
```

---

# 7) 针对你项目各模块的“测试清单”（按优先级）

* **Formatter**（你已经有了）：形状、毫秒、行尾、并发冒烟、二进制安全
* **FileSink**：
  * 正常写：写 3 行 → 文件存在 → 行数/前缀匹配
  * 错误写：只读目录 → 预期报错/返回失败（看你的 API 设计）
* **RollSink**：
  * 小阈值（例如 200B）快速翻卷：写入 N 行后至少出现 2 个文件，且内容无交叉/不丢
  * 文件名排序正确（零填充）
* **Logger(同步)**：
  * level 过滤（设 WARN，写 INFO 不应出现）
  * 多 sink：每条写入被两个 sink 都接收
  * 变参类型匹配（正常路径），传错类型（不可测 → UB，依赖编译器/静态分析）
* **AsyncLooper/AsyncLogger**：
  * push→按顺序到达 FakeSink（用屏障对齐开始），总量正确
  * 背压：容量小、并发多线程 push，不崩溃、不丢/或按策略丢（可测丢弃计数）
  * stop：调用后线程退出；阻塞的 push 被唤醒并返回
  * 竞争冒烟：TSAN 下跑，确保无数据竞争
* **Builder/Manager**：
  * 构建最小 logger，未设置项用默认；重复添加同名是否覆盖/拒绝（定义清晰并测试）

---

# 8) 几个“增压器”：把质量再抬一个台阶

* **Sanitizers**：
  * ASan/UBSan：`-DBITLOG_ENABLE_ASAN=ON -DBITLOG_ENABLE_UBSAN=ON`
  * TSAN（并发）：可单独加个选项，专门跑异步测试
* **覆盖率**（可选）：`llvm-cov`/`gcovr`，盯紧关键分支（错误路径/边界）
* **模糊测试**（fuzz，可选）：对解析器类模块（pattern parser）非常有效
* **持续集成**：在 CI 跑 `ctest -j`、开启 Sanitizers、生成覆盖率报告

---

# 9) “测试异味”（一看到就要修）

* **Sleep 式并发测试**：`std::this_thread::sleep_for(10ms)` 盲等 → 改用条件变量 + 超时
* **无清理的文件测试**：污染工作目录 → 用临时目录 + RAII 清理
* **随机/时区/网络依赖**：导致不稳定 → 注入可控依赖或本地 stub
* **断言过宽或过窄**：`assert(line.size() > 0)` 毫无意义；过窄会频繁误报
* **单测做性能断言**：不稳定 → 迁到基准测试
