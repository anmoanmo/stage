# mylog 使用手册

> 适用对象：需要在 C++17 项目中快速集成**同步/异步**日志、**标准输出/文件/滚动文件**落地的开发者。
> 本手册覆盖 —— 安装集成、快速上手、详尽 API、异步/滚动语义、调优与故障排查。

---

# 1. 环境与安装

## 1.1 依赖与编译器

* C++17 及以上
* POSIX/Windows 通用（Windows 下请以 **binary** 模式打开文件，库内已处理）

## 1.2 集成方式

将项目源文件加入你的工程，并把项目根目录加入 include 路径即可：

```bash
g++ -std=c++17 -O2 -pthread -I./ your_app.cpp -o your_app
```

> 如果你希望用 CMake，我可以根据你的仓库结构给出一份最小可用的 `CMakeLists.txt`。

---

# 2. 快速开始

## 2.1 直接用便捷宏输出到 root 日志器

```cpp
#include "logs/mylog.h"
using namespace mylog;

int main() {
    LOGI("hello %s", "world");
    LOGE("oops, code=%d", 42);
}
```

## 2.2 通过 Builder 创建一个“可复用”的日志器

```cpp
#include "logs/mylog.h"
using namespace mylog;

int main() {
    GlobalLoggerBuilder::ptr lb(new GlobalLoggerBuilder);
    lb->buildLoggerName("async_demo");
    lb->buildLoggerFormatter("%d [%t] %p %c %f:%l\t%m%n");
    lb->buildLoggerSink<StdoutSink>();
    lb->buildLoggerSink<FileSink>("./logs/async.log");
    lb->buildLoggerSink<RollBySizeSink>("./logs/roll", 1 * 1024 * 1024); // 1MB滚动
    lb->buildLoggerType(LoggerType::LOGGER_ASYNC);
    lb->buildAsyncBufferMax(128 * 1024 * 1024);  // 可按需调整
    auto logger = lb->build();                   // 自动注册到 LoggerManager

    logger->info(__FILE__, __LINE__, "ready.");
}
```

## 2.3 在任意地方按名称获取同一个日志器

```cpp
auto lp = LoggerManager::getInstance().getLogger("async_demo");
lp->warn(__FILE__, __LINE__, "hot path");
```

---

# 3. 架构与线程模型

* ​**Logger**​：对外入口；整合日志等级、格式化与 sinks；提供同步/异步两个实现。
* ​**Formatter**​：把 `LogMsg` 按 pattern 渲染成字符串。
* ​**Sink**​：落地策略。内置 `StdoutSink`、`FileSink`、`RollBySizeSink`，可扩展自定义。
* ​**Manager**​：单例，负责日志器注册与检索。
* ​**异步模型**​：​**多生产者（你的业务线程） → 单消费者（后台线程）**​。采用​**双缓冲**​，仅在交换时有一次锁竞争，绝大多数时间无锁工作。

---

# 4. API 参考（常用）

## 4.1 Builder（常用配置）

```cpp
class GlobalLoggerBuilder {
public:
    using ptr = std::shared_ptr<GlobalLoggerBuilder>;
    // 基本：
    void buildLoggerName(const std::string& name);
    void buildLoggerType(LoggerType type);               // LOGGER_SYNC / LOGGER_ASYNC
    void buildLoggerFormatter(const std::string& pat);   // 见 §5
    // 落地：
    template <class Sink, class... Args>
    void buildLoggerSink(Args&&... args);                // FileSink/StdoutSink/RollBySizeSink...
    // 异步：
    void buildAsyncBufferMax(size_t bytes);              // 异步缓冲上限（字节）
    // 完成：
    Logger::ptr build();                                 // 创建并注册到 LoggerManager
};
```

### 常见 Sink 构造参数

* `StdoutSink()`：无参
* `FileSink(const std::string& path)`
* `RollBySizeSink(const std::string& base, size_t max_size_bytes)`

> `build()` 会自动把日志器注册到全局 `LoggerManager`。

## 4.2 Logger（写日志）

```cpp
logger->debug(__FILE__, __LINE__, "x=%d", x);
logger->info(__FILE__, __LINE__, "msg=%s", s.c_str());
logger->warn(__FILE__, __LINE__, "warn ...");
logger->error(__FILE__, __LINE__, "err=%d", ec);
logger->fatal(__FILE__, __LINE__, "fatal");
```

## 4.3 Manager（获取/注册）

```cpp
auto& mgr = LoggerManager::getInstance();
auto lp = mgr.getLogger("async_demo");   // 取回
auto root = mgr.rootLogger();            // root
bool ok = mgr.hasLogger("async_demo");   // 是否存在
// mgr.addLogger(name, logger);          // 通常由 builder->build() 自动完成
```

## 4.4 便捷宏（输出到 root）

```cpp
LOGD("debug value=%d", v);
LOGI("info %s", s.c_str());
LOGW("warn");
LOGE("error");
LOGF("fatal");
```

---

# 5. Formatter（模式串）

常用占位符：

* `%d` 日期时间（固定宽 `HH:MM:SS`）
* `%T` 制表符 `\t`
* `%t` 线程 id
* `%p` 日志级别
* `%c` 日志器名称
* `%f` 源文件名
* `%l` 行号
* `%m` 消息
* `%n` 换行

示例：

```text
%d [%t] %p %c %f:%l\t%m%n
```

> ​**建议**​：如需“滚动文件看起来更均匀”，对数字（如计数器）使用**定宽**输出（例如 `"%03zu"`），使单行字节更稳定。

---

# 6. 落地（Sinks）与滚动语义

## 6.1 StdoutSink / FileSink

* 默认以 `std::ios::binary | std::ios::app` 打开文件，避免换行转换（Windows）。

## 6.2 RollBySizeSink（按大小滚动）

* ​**不拆行**​：滚动发生在​**行边界**​。如果“把这一行写进去会超过阈值且当前文件非空”，则**先滚动**再写这一行。
* ​**大小保证**​：每份文件保证 `≤ max_size`；由于按行对齐，​**各份大小不完全相等属于预期**​（最后一份通常更小）。
* ​**时机建议**​：推荐只做“​**写前预判**​”滚动；避免“写后兜底”在最后一条写完后立刻新开一个空文件。

> 温馨提示：如果你看到“第一个文件很少行、第二个很多行或最后一个空文件”，通常是**按行对齐 + 写后兜底**的结果；只保留“写前预判”即可改善观感。

---

# 7. 异步模型与缓冲

* ​**MPSC**​：多生产者（你的业务线程）写入生产缓冲，消费者线程在被唤醒后把消费缓冲**按行**写入各 sink。
* ​**双缓冲**​：交换时一次互斥，其余写入无锁，避免大量锁争用。
* ​**缓冲上限**​：`buildAsyncBufferMax(bytes)` 用于限制异步缓冲总量，避免异常峰值占满内存。
* ​**文件缓冲**​（实现细节建议）：在 sink 打开文件前设置较大的 `rdbuf`（如 256KB\~1MB）可显著减少系统调用次数、提升吞吐。

---

# 8. 性能与压测

库内提供简单的基准（`bench.h` / `logger.cpp`）：

* 自定义 **线程数** / **总消息数** / **消息长度**
* 同步 / 异步 模式
* 输出每线程耗时、总耗时、平均吞吐（行/s）与平均写入带宽（MiB/s）

​**计时语义**​：默认覆盖​**生产者侧写入/入队**​。
​**端到端落盘**​：如需统计“写出完成”，请在基准收尾对目标日志器调用你实现的同步点（例如 `flush()`/`drain()`）后再停表。

**实测参考（你的环境）**

* 中等规模：异步 5 线程 ≈ ​**2.9M 行/s**​（约 ​**275 MB/s**​），异步 1 线程 ≈ **1.55M 行/s**
* 极限规模（10^7 条 / \~1KB/条）：异步 1 线程 ≈ ​**448K 行/s**​（约 ​**427 MB/s**​），异步 100 线程 ≈ ​**575K 行/s**​（约 ​**547 MB/s**​）

> 解释：单文件写入受**单消费者线程 + 存储带宽**限制；多生产者通常**不会线性扩展**属常态。极限带宽多为​**页缓存写入**​，与“强持久化”不同。

---

# 9. 调优建议

1. ​**固定行长**​：把数字字段定宽（如 `%03zu`），单行字节稳定有助滚动观感与吞吐稳定性。
2. ​**只写前预判滚动**​：避免最后开空文件、减少一次 rotate。
3. ​**扩大文件缓冲**​：在 sink 打开前设置较大的 `rdbuf`（256KB\~1MB），减少 write 次数。
4. ​**异步缓冲上限**​：按峰值调整 `buildAsyncBufferMax()`，避免极端流量时占满内存。
5. ​**减少热路径格式化**​：避免每条做 `localtime` 等昂贵操作；可缓存线程名、预拼模板。
6. ​**多消费者/分片（可选）**​：若需近线性扩展，可将同一日志器拆为 N 个文件/消费者线程（代价是日志分散，合并分析复杂）。

---

# 10. 常见问题（FAQ）

**Q1：为什么滚动文件的大小不一致？**
A：因为**按行对齐**不拆行；当下一行会超过剩余空间就提前滚动，保证每份 `≤ 阈值`，但不等于“每份完全相等”。

**Q2：为何有时最后会出现一个空的下一份滚动文件？**
A：如果实现了“写后兜底 rotate”，当最后一行写完达到阈值时会立刻开新文件，但没有后续写入，导致空文件。仅保留“写前预判”即可避免。

**Q3：多线程生产者下吞吐为什么不是线性提升？**
A：同一日志器落地到​**同一文件**​，最终由**单消费者线程**串行写出；存储带宽也会成为上限，故不会线性扩展。

**Q4：Windows 下文件大小为何和估算不一致？**
A：若不是以 **binary** 打开，`\n` 会被转换为 `\r\n`，实际写入字节多于估算。库内默认使用 binary。

---

# 11. 目录结构（参考）

* `level.hpp`：日志等级
* `message.hpp`：日志消息对象
* `format.hpp`：模式串与 `FormatItem`
* `buffer.hpp` / `looper.hpp`：双缓冲与异步消费者
* `sink.hpp`：Stdout/File/Rolling 等落地
* `logger.hpp`：同步/异步日志器、Builder、Manager
* `logs/mylog.h`：对外统一头与便捷宏
* `bench.h` / `logger.cpp`：基准测试
* `util.hpp`：时间/文件工具
* `sin_extend.hpp`：辅助扩展（如有）

---

# 12. 版本与兼容性

* C++17 标准
* 不同平台的文件系统/时间函数可能略有差异；滚动命名含时间戳与序号，跨秒时文件序号会从 0 重新计数，属预期。

---

# 13. 许可证

MIT（如仓库未附带，请根据实际授权情况补充或更新）

---

## 附录 A：最小可编译示例（单文件）

```cpp
#include "logs/mylog.h"
using namespace mylog;

int main() {
    // 构建异步日志器
    GlobalLoggerBuilder::ptr lb(new GlobalLoggerBuilder);
    lb->buildLoggerName("demo");
    lb->buildLoggerFormatter("%d %p %c %m%n");
    lb->buildLoggerSink<FileSink>("./logs/app.log");
    lb->buildLoggerType(LoggerType::LOGGER_ASYNC);
    lb->buildAsyncBufferMax(32 * 1024 * 1024);
    auto logger = lb->build();

    // 写日志
    for (int i = 0; i < 5; ++i)
        logger->info( "hello %03d", i);

    // 便捷宏（root）
    LOGI("done.");
    return 0;
}
```

---

