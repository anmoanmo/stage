# 目的

1. 多落地方向：日志将消息进行格式化为指定格式的字符串之后，写入指定位置（标准输出，指定文件，滚动文件...）
2. 同步/异步：日志写入指定位置时，支持不同的写入方式
3. 多输出策略：日志输出以日志器为单位，支持多日志器

# 日志系统框架设计

## 日志等级模块

枚举出多个等级，对不同的日志进行不同等级标志--便于控制输出

## 日志消息模块

封装一条日志所需要的各种要素

◦ 时间：描述本条⽇志的输出时间。
◦ 线程ID：描述本条⽇志是哪个线程输出的。
◦ ⽇志等级：描述本条⽇志的等级。
◦ ⽇志数据：本条⽇志的有效载荷数据。
◦ ⽇志⽂件名：描述本条⽇志在哪个源码⽂件中输出的。
◦ ⽇志⾏号：描述本条⽇志在源码⽂件的哪⼀⾏输出的

## 日志消息格式化模块

按照指定的格式，对日志消息关键要素进行组织，最终得到一个指定格式的字符串

日志格式化（Formatter）类主要负责格式化日志消息。其主要包含以下内容

- **pattern 成员**：保存日志输出的格式字符串。
  
  - `%d` 日期
  - `%T` 缩进
  - `%t` 线程 id
  - `%p` 日志级别
  - `%c` 日志器名称
  - `%f` 文件名
  - `%l` 行号
  - `%m` 日志消息
  - `%n` 换行

## 日志器模块

对上述模块的整合

日志限制输出等级，消息格式化模块对象，日志落地模块对象

同步日志器模块

异步日志器模块

异步线程模块：负责日志日志的实际落地模块

单例的日志器管理模块：对日志进行全局的管理，以便于能够在项目的任何

# 代码设计

## 实用类设计（util）

提前完成⼀些零碎的功能接⼝，以便于项⽬中会⽤到。
• 获取系统时间
• 判断⽂件是否存在
• 获取⽂件的所在⽬录路径
• 创建⽬录提供接下来会用到的工具

## 日志等级类设计（level）

⽇志等级总共分为7个等级，分别为：
• OFF：关闭所有⽇志输出
• DRBUG：进⾏debug时候打印⽇志的等级
• INFO：打印⼀些⽤⼾提⽰信息
• WARN：打印警告信息
• ERROR：打印错误信息
• FATAL：打印致命信息-导致程序崩溃的信息

## 日志消息类设计（message）

⽇志消息类主要是封装⼀条完整的⽇志消息所需的内容，其中包括⽇志等级、对应的logger、name、打印⽇志源⽂件的位置信息（包括⽂件名和⾏号）、线程ID、时间戳信息、具体的⽇志信息等内容。

## 日志输出格式化类设计

按照指定的格式，对日志消息关键要素进行组织，最终得到一个指定格式的字符串

日志格式化（Formatter）类主要负责格式化日志消息。其主要包含以下内容

- **pattern 成员**：保存日志输出的格式字符串。
  - `%d` 日期
  - `%T` 缩进
  - `%t` 线程 id
  - `%p` 日志级别
  - `%c` 日志器名称
  - `%f` 文件名
  - `%l` 行号
  - `%m` 日志消息
  - `%n` 换行
- **std::vector[FormatItem::ptr](FormatItem::ptr) items 成员**：用于按序保存格式化字符串对应的子格式化对象。

**FormatItem 类**主要负责日志消息子项的获取及格式化。其包含以下子类：

- **MsgFormatItem**：表示要从 LogMsg 中取出有效日志数据
- **LevelFormatItem**：表示要从 LogMsg 中取出日志等级
- **LoggerFormatItem**：表示要从 LogMsg 中取出日志器名称
- **ThreadFormatItem**：表示要从 LogMsg 中取出线程 ID
- **TimeFormatItem**：表示要从 LogMsg 中取出时间戳并按照指定格式进行格式化
- **FileFormatItem**：表示要从 LogMsg 中取出源码所在文件名
- **LineFormatItem**：表示要从 LogMsg 中取出源码所在行号
- **TabFormatItem**：表示一个制表符缩进
- **NLineFormatItem**：表示一个换行
- **OtherFormatItem**：表示非格式化的原始字符串

需要先完成格式化子项类的定义与实现

实现思路：从日志消息（message）中取出指定的元素，追加到一块内存空间中

设计思想：

1.抽象一个格式化子项基类

2.派生出不同的格式化子项子类

3.在父类中定义父类指针数组，指向不同的格式化子项子类对象

## ⽇志落地(LogSink)类设计

功能：将格式化完成后的日志消息字符串输出到指定的位置

扩展：支持同时将日志落地到不同的位置（1.标准输出；2.指定文件输出；3.滚动文件输出）

支持落地方向的扩展，用户可以自己编写新的落地模块，将日志进行其他方向的落地

### 实现思想：

1.抽象出落地模块类

2.从不同落地方向从基类进行派生

3.使用工厂模式进行创建和表示的分离

## ⽇志落地(LogSink)类设计

功能：对之前所有模块进行整合 ，向外提供接口，完成不同等级日志的输出

管理成员

1.大于等于限制等级的日志才能输出

2.格式化模块对象

3.落地模块对象

4.互斥锁（线程安全）

5.日志器名称（日志器的唯一标识，便于搜索）

提供操作：

各等级日志的输出操作

实现：

1.抽象Logger基类（派生同步日志器类/异步日志器类）

2.抽象落地操作（因为两种日志器仅落地方式不同）

----不同的日志器调用各自的落地操作进行日志落地

----模块关联中使用寄了我i只针对子类日志器对象进行日志管控和操作

### 异步落地

实现：

1.实现一个线程安全的缓冲区

2.创建一个异步工作线程，专门负责缓冲区中日志消息的落地操作

缓冲区详细设计：

1.使用队列缓存日志消息，逐条处理
要求：不涉及到空间的频繁申请和释放（会降低效率）
结果：设计一个环形队列（提取申请好空间，对空间循环利用）
缓冲区的操作必须保证线程安全（设计多线程，对读写锁进行读写加锁）
因为写日志操作在实际开发中不会占用太多资源，所以工作线程只需要一个日志器

涉及到的锁冲突：生产者与生产者的互斥&生产者与消费者的互斥
问题：锁冲较为严重（所有线程都存在互斥关系）
解决方案：双缓冲区（任务写入缓冲区 & 任务处理缓冲区），只有在交换数据时，生产者和消费者才会产生一次锁冲突

单个缓冲区的进一步设计（直接存放格式化后的日志消息字符串）：
好处：1.减少LogMsg对象频繁构造的消耗，2.可以对缓冲区内的日志消息一次性进行IO操作，提高效率
缓冲区设计：
1.管理一个存放字符数据的缓冲区（使用vector进行空间管理）
2.当前的写入数据指针（指向可写区的起始位置，避免写入覆盖）
3.当前的读取数据指针（指向可读区的起始位置，避免重复写入）
4.写入指针&读取指针重叠时则表示数据已处理完

提供的操作：
1.向缓冲区写入操作
2.获取可读数据起始地址的接口（读取指定长度数据
3.获得可读数据长度的接口
4.移动读写位置的接口
5.初始化缓冲区的操作（将读写位置初始化，将一个缓冲区所有数据处理完后）
5.提供交换缓冲区的操作（）

