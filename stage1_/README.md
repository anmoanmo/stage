安装与构建下面是一份可直接粘贴到项目 `README.md` 的完整版（在你原始 README 的基础上做了结构化与细化），涵盖整体架构、使用方式、滚动语义、异步模型、性能基准与调优建议，便于新读者快速上手，也便于后续对外展示与对比。

---

# mylog —— 轻量高性能 C++17 日志库

> 一个支持多落地（stdout / 文件 / 按大小滚动）、**同步/异步**两种写入策略、​**多日志器并存**​、Builder/Manager 管理的一体化 C++17 日志库。
> 目标是：​**简单易用**​、​**可扩展**​、​**高吞吐**​，并在“行不被拆分”的前提下提供稳定的滚动行为。

---

## 目录

- *特性总览*
- *架构与模块*
- *安装与构建*
- *快速开始*
- *日志格式（Formatter）*
- *落地模块（Sinks）*
- *异步模型与缓冲*
- *日志器管理（Manager）*
- *全局接口与宏*
- *滚动文件的语义与示例*
- *性能与压测*
- *调优建议*
  *常见问题（FAQ）*
  *目录结构*
  *设计约束与注意事项*

## 特性总览

* ​**多落地方向**​：标准输出、普通文件、按大小滚动文件（可扩展自定义 sink）。
* ​**同步 / 异步**​：同一套 API，按需切换写入策略。
* ​**多日志器并存**​：按“日志器名称”区分，提供全局 Manager 统一检索/复用。
* ​**可定制格式化**​：pattern 支持 `%d/%t/%p/%c/%f/%l/%m/%n/%T` 等占位符。
* ​**行不拆分**​：滚动发生在​**行边界**​，保证每一行完整写入同一文件。
* ​**轻量依赖**​：纯头文件/少量 cpp，C++17 标准库，无第三方依赖。

---

## 架构与模块

* ​**level.hpp**​：日志等级枚举与比较。
* ​**message.hpp**​：`LogMsg`——一条日志的时间戳、线程 id、级别、消息体、源文件与行号等。
* ​**format.hpp**​：`Formatter` + 若干 `FormatItem`，将 `LogMsg` 按 pattern 生成最终字符串。
* ​**sink.hpp**​：落地抽象与实现（`StdoutSink`、`FileSink`、`RollBySizeSink`），另有 `SinkFactory` 简化创建。
* ​**buffer.hpp**​：无锁/轻锁的内存缓冲（生产/消费区、读写指针、交换/重置）。
* ​**looper.hpp**​：异步后台线程（消费者），负责批量把缓冲内容写入 sink。
* ​**logger.hpp**​：`Logger` 抽象、`SyncLogger`/`AsyncLogger` 实现、`GlobalLoggerBuilder`、`LoggerManager`（单例）。
* ​**util.hpp**​：时间、文件路径、目录等基础工具。
* ​**mylog.h**​：对外统一头（便捷宏 `LOGx`、全局获取等）。

> 设计原则：**Logger** 只负责“收集 + 格式化 + 投递”，**Sink** 只负责“落地”，**异步线程**只在缓冲交换时有一次锁竞争，绝大多数时间无锁工作。

---

## 安装与构建

* 需要 **C++17** 及以上编译器。
* 将本仓库头文件路径加入 `-I`，与工程一同编译链接即可。

```bash
g++ -std=c++17 -O2 -pthread -I./ your_app.cpp -o your_app
```

> 若需要示例的 `CMakeLists.txt`，可按项目目录结构新增（请告知我你的最终目录布局，我可以给出可直接用的 CMake 模板）。

---

## 快速开始

### 1) 便捷宏（写到 root 日志器）

```cpp
#include "logs/mylog.h"
using namespace mylog;

LOGI("hello %s", "world");
LOGE("oops, code=%d", 42);
```

### 2) 通过 Builder 自定义日志器（推荐）

```cpp
using namespace mylog;

GlobalLoggerBuilder::ptr lb(new GlobalLoggerBuilder);
lb->buildLoggerName("async_demo");
lb->buildLoggerFormatter("%d [%t] %p %c %f:%l\t%m%n");
lb->buildLoggerSink<StdoutSink>();
lb->buildLoggerSink<FileSink>("./logs/async.log");
// 按大小滚动：1MB 阈值（单位：字节）
lb->buildLoggerSink<RollBySizeSink>("./logs/roll", 1 * 1024 * 1024);
lb->buildLoggerType(LoggerType::LOGGER_ASYNC);
// 异步缓冲上限（按需调整）
lb->buildAsyncBufferMax(128 * 1024 * 1024);

auto logger = lb->build();
logger->info(__FILE__, __LINE__, "ready.");
```

### 3) 任意处按名称获取

```cpp
auto lp = LoggerManager::getInstance().getLogger("async_demo");
lp->warn(__FILE__, __LINE__, "hot path");
```

---

## 日志格式（Formatter）

​**占位符（常用）**​：

* `%d` 日期时间（固定宽 `HH:MM:SS`）
* `%T` 制表符缩进
* `%t` 线程 id
* `%p` 日志级别
* `%c` 日志器名称
* `%f` 文件名
* `%l` 行号
* `%m` 日志消息
* `%n` 换行

​**示例 Pattern**​：

```text
%d [%t] %p %c %f:%l\t%m%n
```

> 提示：在压测或追求“滚动文件看起来更均匀”时，让可变数字字段​**定宽输出**​（例如把计数打印成 `%03zu`），这样单行字节更稳定。

---

## 落地模块（Sinks）

* ​**StdoutSink**​：写到标准输出。
* ​**FileSink**​：写到指定文件（建议 `std::ios::binary | std::ios::app`）。
* ​**RollBySizeSink**​：按大小滚动。
  * ​**行对齐**​：滚动发生在​**行边界**​，不会拆分一行。
  * ​**<= 阈值**​：每个文件大小保证 ​**≤ 设定阈值**​；由于行对齐，​**无法保证每份完全相等**​（最后一份通常更小）。
  * ​**时机选择**​：推荐仅“​**写前预判**​”进行滚动，避免“写后兜底”在末尾多开一个空文件。

> 扩展：你可以实现自定义 sink（例如网络、系统日志或专有存储），通过 `SinkFactory` 无缝纳入。

---

## 异步模型与缓冲

* ​**双缓冲**​：生产者写“生产缓冲区”，消费者线程处理“消费缓冲区”；仅在交换时有一次锁竞争，其余时间处于无锁状态。
* ​**逐行投喂**​：消费者按 `'\n'` 拆分**逐行**调用 `sink->log()`，从而确保滚动发生在行边界。
* ​**缓冲上限**​：`buildAsyncBufferMax(size_t bytes)` 用于限制异步缓冲最大内存，以规避极端压力下的内存风险。
* ​**文件缓冲**​：在 sink 打开文件前可设置更大的 `rdbuf`（如 256KB\~1MB），可显著降低 write 次数、提升吞吐。

---

## 日志器管理（Manager）

* ​**单例**​：`LoggerManager::getInstance()`
* ​**接口**​：
  * `addLogger(name, logger)`：注册
  * `hasLogger(name)`：是否存在
  * `getLogger(name)`：取回
  * `rootLogger()`：root 实例（默认 stdout 或构造时指定）
* ​**行为**​：Builder 的 `build()` 会自动注册该日志器；也可按需手工维护。

---

## 全局接口与宏

* 便捷宏：`LOGD/LOGI/LOGW/LOGE/LOGF/...` —— 输出到 root。
* 便捷函数：`getLogger("name")` 直接获取指定日志器。
* 宏内部可包含 `__FILE__/__LINE__` 等定位信息。

---

## 滚动文件的语义与示例

​**目标**​：以“​**行为原子**​”进行滚动，保持每行完整性。

​**写入策略**​（推荐实现/配置）：

```text
if (_cur_size + line_len > max_size && _cur_size > 0) {
    rotate();                 // 写前预判滚动
}
write(line);
_cur_size += line_len;
// 写后不 rotate；满了等下一行写前再 rotate
```

**为何“大小不完全相等”？**

* 因为**每行字节数**未必恒定（例如计数位数变化），即便固定宽，最后一行写入也只能保证“≤ 阈值”，而非“== 阈值”。
* 如果尾部出现“空文件”，通常是“写后兜底”造成——去掉兜底，改成仅“写前预判”即可避免。

​**示例**​：

```cpp
// 1MB 阈值，按行滚动
lb->buildLoggerSink<RollBySizeSink>("./logs/roll", 1 * 1024 * 1024);
```

---

## 性能与压测

仓库提供基准程序（`bench.h` / `logger.cpp`），可配置：

* 生产者**线程数**
* **总消息数**
* **单条消息长度**
* 同步 / 异步 模式

程序输出每线程耗时、总耗时、平均吞吐（行/s）、平均写入速率（MiB/s）。

​**注意**​：默认计时覆盖​**生产者侧写入/入队**​；如需统计“端到端落盘完成”，在收尾对目标 logger 执行 `flush()/drain()` 等待异步队列清空后再停表（可在接口层增加一个同步点）。

### 你的实测（示例对外展示用）

* ​**中等规模**​（示例，消息体较短）
  * 异步·5 线程：≈ ​**2.89M 行/s**​（约 ​**275 MB/s**​）
  * 异步·1 线程：≈ ​**1.55M 行/s**​（约 ​**148 MB/s**​）
  * 同步·1 线程：≈ ​**1.04M 行/s**​（约 ​**99 MB/s**​）
  * 同步·5 线程：≈ ​**0.665M 行/s**​（约 ​**63 MB/s**​）
* **极限规模（10,000,000 条 / \~1KB 消息）**
  * 异步·1 线程：≈ ​**448 K 行/s**​（约 ​**427 MB/s**​）
  * 异步·100 线程：≈ ​**575 K 行/s**​（约 ​**547 MB/s**​）
  * 同步·1 线程：≈ ​**377 K 行/s**​（约 ​**359 MB/s**​）
  * 同步·100 线程：≈ ​**197 K 行/s**​（约 ​**187 MB/s**​）

> 解读：
> 
> * 异步明显优于同步，符合“生产者与写出解耦”的预期。
> * 单文件写出天然受**单消费者线程 + 存储带宽**限制，**多生产者**不会线性扩展属常态。
> * 以上带宽很可能是​**页缓存写入吞吐**​，若需“落盘持久化”指标，请开启/控制 `fsync` 周期另测。

---

## 调优建议

* ​**格式化成本**​：热路径尽量避免昂贵操作（如逐条 `localtime`），可缓存线程名、预拼模板等。
* ​**行长稳定**​：定宽打印数字字段（如 `%03zu`）让单行字节更稳定，有助滚动更“整齐”。
* ​**文件缓冲**​：在 sink 打开文件前设置更大的 `rdbuf`（256KB\~1MB），有效减少 write 次数。
* ​**异步缓冲**​：按业务峰值调整 `buildAsyncBufferMax()`，避免极端峰值触顶。
* ​**flush 策略**​：避免频繁 `flush()`；必要时提供节流（按时间/按条数/按字节）。
* ​**多消费者/分片（可选）**​：若需线性扩展吞吐，可将同一日志器拆为 N 份文件/消费者线程；代价是日志分布于多文件、聚合分析变复杂。
* ​**Windows 注意**​：务必使用 **binary** 打开文件，避免 `\n` → `\r\n` 自动转换造成“统计字节 vs 实际字节”不一致。

---

## 常见问题（FAQ）

**Q：为什么滚动文件的大小不完全一致？**
A：因为**行对齐**策略不会拆分行，下一行可能会超过剩余空间而提前滚动；因此只保证“≤ 阈值”，不保证“== 阈值”。

**Q：为什么最后可能会出现一个空的下一份滚动文件？**
A：如果采用“写后兜底 rotate”，在最后一行写完且达到阈值时会立即新开一个文件，但这轮没有后续写入，就会留下一个空文件。改为仅“写前预判”即可避免。

**Q：异步写为什么多线程生产者下不是线性加速？**
A：同一日志器的“单文件落地”物理上需要串行写；即使入队并行，最终写出由单消费者线程与存储带宽主导，因此不会线性扩展。

**Q：如何测“端到端落盘完成”的耗时？**
A：在基准/业务收尾对目标 logger 调用 `flush()/drain()` 等待后台队列清空，再统计耗时；如需强一致持久化，可配置 `fsync` 周期。

---

## 目录结构

* `level.hpp`：日志等级
* `message.hpp`：日志消息对象
* `format.hpp`：pattern 与 `FormatItem` 实现
* `buffer.hpp` / `looper.hpp`：双缓冲与异步消费者
* `sink.hpp`：Stdout/File/Rolling 等落地
* `logger.hpp`：同步/异步日志器与管理器
* `logs/mylog.h`：对外头文件与便捷宏
* `bench.h` / `logger.cpp`：基准测试入口与配置
* `util.hpp`：时间/文件等基础工具
* `sin_extend.hpp`：项目内部扩展/辅助（如有）

---

## 设计约束与注意事项

* ​**滚动按行**​：不会拆分日志行；文件大小保证 `≤ 阈值`，不保证各份完全一致。
* ​**单消费者**​：默认一个后台线程处理同一日志器写出；如需线性扩展，需采用分片/多文件策略。
* ​**线程安全**​：生产者与 Manager 路径均做了必要加锁；异步路径仅在缓冲交换时存在锁竞争。
* ​**可扩展**​：支持自定义 sink / formatter；对外 API 保持稳定。

---

## 许可证

MIT（如仓库未附带，请根据实际授权情况补充或更新）

---

